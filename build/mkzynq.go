// Copyright 2014 Brian Swetland <swetland@frotz.net>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Tool to generate a SystemVerilog wrapper around the Xilinx Zynq PS7 Macro

package main

import "flag"
import "os"
import "bufio"
import "strings"
import "strconv"
import "fmt"

type net struct {
	next *net
	kind string
	def string
	name string
	value string
}

const (
	SIMPLE_FIXUP = 1
	PREFIX_FIXUP = 2
)

type fixup struct {
	next *fixup
	pattern string
	mapping string
	kind int
}

func fixup_nets(netlist *net, fixups *fixup) {
	for n := netlist; n != nil; n = n.next {
		for f := fixups; f != nil; f = f.next {
			if (f.kind == PREFIX_FIXUP) && strings.HasPrefix(n.name, f.pattern) {
				n.value = f.mapping + strings.ToLower(strings.TrimPrefix(n.name, f.pattern))
				goto fixedup
			}
			if (f.kind == SIMPLE_FIXUP) && (n.name == f.pattern) {
				n.value = f.mapping
				goto fixedup
			}
		}
		// tie off unmapped input nets
		if n.kind == "input" {
			n.value = "0"
		}
fixedup:
	}
}

// extract  input|output|inout [...] <name>;  lines from blackbox macro verilog source

func load_template(fn string) *net {
	var netlist *net
	file, _ := os.Open(fn)
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		line = strings.TrimSpace(line)
		if !strings.HasSuffix(line, ";") {
			continue
		}
		line = line[:len(line)-1]
		parts := strings.Split(line, " ");
		if (parts[0] != "input") && (parts[0] != "output") && (parts[0] != "inout") {
			continue;
		}
		if (len(parts) == 3) {
			netlist = &net{
				next: netlist,
				kind: parts[0],
				def: parts[1],
				name: parts[2],
			}
		} else if (len(parts) == 2) {
			netlist = &net{
				next: netlist,
				kind: parts[0],
				def: "",
				name: parts[1],
			}
		} else {
			continue;
		}
	}
	return netlist
}

var axi_m_gp = flag.Int("axi-master-gp", 0, "number of gp axi master ifcs (0-2)")
var axi_s_gp = flag.Int("axi-slave-gp", 0, "number of gp axi slave ifcs (0-2)")
var axi_s_hp = flag.Int("axi-slave-hp", 0, "number of gp axi slave ifcs (0-4)")
var fclks = flag.Int("fclks", 1, "number of clocks from PS")
var tmpl = flag.String("template", "PS7.v", "template for PS7 macro")

var fixups *fixup
var ports *net

func mkport(kind string, def string, name string) {
	ports = &net{
		next: ports,
		kind: kind,
		def: def,
		name: name,
		}
}

func prefix_fixup(prefix string, mapping string) {
	fixups = &fixup {
		next: fixups,
		kind: PREFIX_FIXUP,
		pattern: prefix,
		mapping: mapping,
	}
}

func simple_fixup(prefix string, mapping string) {
	fixups = &fixup {
		next: fixups,
		kind: SIMPLE_FIXUP,
		pattern: prefix,
		mapping: mapping,
	}
}

func fixup_axi(count int, prefix string, mapping string, kind string) {
	defval := ""
	if (kind == "axi_ifc.slave") {
		defval = "0"
	}
	for n := 1; n <= count; n++ {
		num := strconv.Itoa(n-1)
		prefix_fixup(prefix + num, mapping + num + ".")
		simple_fixup(prefix + num + "ACLK", mapping + num + "_clk")
		simple_fixup(prefix + num + "AWQOS", defval)
		simple_fixup(prefix + num + "ARQOS", defval)
		simple_fixup(prefix + num + "AWPROT", defval)
		simple_fixup(prefix + num + "ARPROT", defval)
		simple_fixup(prefix + num + "WID", defval)
		simple_fixup(prefix + num + "ARESETN", "")
		simple_fixup(prefix + num + "WRISSUECAP1EN", "0")
		simple_fixup(prefix + num + "RDISSUECAP1EN", "0")
		simple_fixup(prefix + num + "WACOUNT", "")
		simple_fixup(prefix + num + "RACOUNT", "")
		simple_fixup(prefix + num + "WCOUNT", "")
		simple_fixup(prefix + num + "RCOUNT", "")
		mkport(kind, "", mapping + num)
		mkport("input", "", mapping + num + "_clk")
	}
}

func main() {
	flag.Parse()

	netlist := load_template(*tmpl)

	fixup_axi(*axi_m_gp, "MAXIGP", "m_axi_gp", "axi_ifc.master")
	fixup_axi(*axi_s_gp, "SAXIGP", "s_axi_gp", "axi_ifc.slave")
	fixup_axi(*axi_s_hp, "SAXIHP", "s_axi_hp", "axi_ifc.slave")

	// route clocks out from PS7
	simple_fixup("FCLKCLK", "{ fclk3_i, fclk2_i, fclk1_i, fclk0_i }")
	for n := 0; n < *fclks; n++ {
		mkport("output", "", "fclk" + strconv.Itoa(n))
	}

	fixup_nets(netlist, fixups)

	fmt.Printf("// machine-generated by mkzynq.go - do not edit\n")
	fmt.Printf("`timescale 1ns / 1ps\n\n")
	fmt.Printf("module zynq_ps7(\n")
	for p := ports; p != nil; p = p.next {
		if p.next != nil {
			fmt.Printf("\t%s %s,\n", p.kind, p.name)
		} else {
			fmt.Printf("\t%s %s\n", p.kind, p.name)
		}
	}
	fmt.Printf("\t);\n\n")

	// global buffers for active clocks from PS
	fmt.Printf("wire fclk0_i, fclk1_i, fclk2_i, fclk3_i;\n\n")
	for n := 0; n < *fclks; n++ {
		fmt.Printf("BUFG fclk%d_bufg(.I(fclk%d_i), .O(fclk%d));\n", n, n, n);
	}

	fmt.Printf("\nPS7 ps7_i(\n")
	for n := netlist; n != nil; n = n.next {
		if n.next != nil {
			fmt.Printf("\t.%s(%s),\n", n.name, n.value)
		} else {
			fmt.Printf("\t.%s(%s)\n", n.name, n.value)
		}
	}
	fmt.Printf("\t);\n\nendmodule\n")
}

